<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¢µé«˜åä½œç²’å­äº¤äº’ (CORSä¿®å¤ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .input_video { display: none; }
        
        /* UI æç¤ºå±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none;
            user-select: none;
        }
        h1 { 
           margin: 0; 
            font-size: 3.5rem; 
            
            letter-spacing: 2px; 
            text-transform: uppercase; 
            background: linear-gradient(to right, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent; 
            filter: drop-shadow(0 2px 5px rgba(0,0,0,0.8));
            font-weight: 800;
        } 
        }
        p { margin: 8px 0; font-size: 1rem; opacity: 0.8; }
        .instruction { font-size: 0.9rem; color: #aaa; margin-bottom: 5px; }
        .status { 
            margin-top: 15px; 
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-left: 4px solid #4db8ff;
            border-radius: 4px;
            display: inline-block;
            font-weight: bold; 
            color: #fff; 
            backdrop-filter: blur(5px);
        }
        
        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
            transition: opacity 0.5s ease;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- UI -->
    <div id="ui-layer">
        <h1>Van Gogh Particles</h1>
        <div class="instruction">è¯·ç¡®ä¿åœ¨ Localhost æˆ– HTTPS ç¯å¢ƒä¸‹è¿è¡Œä»¥å¯ç”¨æ‘„åƒå¤´</div>
        <p>ğŸ–ï¸ <b>å¼ å¼€æ‰‹æŒ</b>: ç²’å­æ•£å¼€å¹¶è·Ÿéš (æ˜Ÿç³»æ¨¡å¼)</p>
        <p>âœŠ <b>æ¡ç´§æ‹³å¤´</b>: æŠ“å–å¹¶åˆ‡æ¢ç”»ä½œ (è¿˜åŸæ¨¡å¼)</p>
        <div class="status" id="status-text">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div>
    </div>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">æ­£åœ¨é€šè¿‡ä»£ç†ä¸‹è½½å¹¶è§£æåç”»...</div>
    </div>

    <!-- MediaPipe Video Input (Hidden) -->
    <video class="input_video"></video>
    
    <!-- Three.js Container -->
    <div id="canvas-container"></div>

    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Main Logic -->
    <script>
        /**
         * 1. é…ç½®ä¸å…¨å±€å˜é‡
         */
        const CONFIG = {
            particleCount: 256 * 256, // 65536 ä¸ªç²’å­
            texSize: 256,             // çº¹ç†é‡‡æ ·å°ºå¯¸
            pointSize: 2.5,
            transitionSpeed: 0.05
        };

        // ä½¿ç”¨ wsrv.nl ä»£ç†æœåŠ¡è§£å†³ CORS é—®é¢˜ï¼Œå¹¶é™åˆ¶å®½åº¦ä¸º 512px æé«˜åŠ è½½é€Ÿåº¦
        const IMAGE_URLS = [
            'æ˜Ÿæœˆå¤œ.jpg', // æ˜Ÿæœˆå¤œ
            'å‘æ—¥è‘µ.jpg', // å‘æ—¥è‘µ
            'éº¦ç”°ç¾¤é¸¦.jpg', // éº¦ç”°ç¾¤é¸¦
            'ç½—çº³æ²³ä¸Šçš„æ˜Ÿå¤œ.jpg' // ç½—çº³æ²³ä¸Šçš„æ˜Ÿå¤œ
        ];

        let camera, scene, renderer;
        let particleSystem, uniforms;
        let imageTextures = []; 
        let currentImageIndex = 0;
        
        // äº¤äº’çŠ¶æ€
        const STATE = {
            isHandDetected: false,
            isFist: false,
            handPosition: new THREE.Vector2(0, 0), 
            mode: 0.0, // 0.0 = è¿˜åŸ, 1.0 = æ•£å¼€
            lastFistState: false
        };

        const statusText = document.getElementById('status-text');
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');

        /**
         * 2. èµ„æºé¢„åŠ è½½
         */
        async function preloadImages() {
            const loaderObj = new THREE.ImageLoader();
            // å…³é”®ï¼šå…è®¸è·¨åŸŸè¯·æ±‚
            loaderObj.setCrossOrigin('Anonymous');

            const promises = IMAGE_URLS.map((url, index) => {
                return new Promise((resolve, reject) => {
                    loaderObj.load(
                        url, 
                        (image) => {
                            // ç»˜åˆ¶åˆ° Canvas è·å–åƒç´ æ•°æ®
                            const canvas = document.createElement('canvas');
                            canvas.width = CONFIG.texSize;
                            canvas.height = CONFIG.texSize;
                            const ctx = canvas.getContext('2d');
                            
                            // å±…ä¸­è£å‰ª
                            const aspect = image.width / image.height;
                            let sx, sy, sw, sh;
                            if (aspect > 1) {
                                sh = image.height; sw = image.height;
                                sx = (image.width - image.height) / 2; sy = 0;
                            } else {
                                sw = image.width; sh = image.width;
                                sx = 0; sy = (image.height - image.width) / 2;
                            }
                            
                            ctx.drawImage(image, sx, sy, sw, sh, 0, 0, CONFIG.texSize, CONFIG.texSize);
                            
                            try {
                                const imgData = ctx.getImageData(0, 0, CONFIG.texSize, CONFIG.texSize);
                                const texture = new THREE.DataTexture(
                                    imgData.data,
                                    CONFIG.texSize,
                                    CONFIG.texSize,
                                    THREE.RGBAFormat
                                );
                                texture.flipY = true;
                                texture.needsUpdate = true;
                                resolve(texture);
                            } catch (e) {
                                reject("Canvasè¢«æ±¡æŸ“ï¼ŒCORSå¤´æœªç”Ÿæ•ˆ");
                            }
                        }, 
                        undefined, 
                        () => reject(`åŠ è½½å¤±è´¥: å›¾ç‰‡ ${index + 1}`)
                    );
                });
            });

            try {
                imageTextures = await Promise.all(promises);
                initThree();
            } catch (err) {
                console.error(err);
                loaderText.innerHTML = "èµ„æºåŠ è½½å¤±è´¥<br>è¯·æ£€æŸ¥ç½‘ç»œæˆ–ä½¿ç”¨ Localhost è¿è¡Œ";
                loader.querySelector('.spinner').style.display = 'none';
            }
        }

        /**
         * 3. GLSL Shaders
         */
        const vertexShader = `
            uniform float time;
            uniform float mode; 
            uniform vec2 handPos;
            uniform sampler2D currentTex; 
            uniform float pointSize;
            
            attribute vec2 uvRef; 
            attribute vec3 randoms; 

            varying vec3 vColor;

            // Simplex Noise
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            void main() {
                // ç›®æ ‡ä½ç½® (å›¾åƒè¿˜åŸ)
                vec3 targetPos = vec3(uvRef.x * 2.0 - 1.0, uvRef.y * 2.0 - 1.0, 0.0);
                
                // æµåŠ¨ä½ç½® (æ˜Ÿç³»)
                vec3 flowPos = targetPos;
                
                float noiseScale = 1.2;
                float t = time * 0.4;
                float n1 = snoise(vec2(flowPos.x * noiseScale + t, flowPos.y * noiseScale));
                float n2 = snoise(vec2(flowPos.x * noiseScale - t, flowPos.y * noiseScale + 15.0));
                
                // å™ªéŸ³ä½ç§»
                flowPos.x += n1 * 0.4 * mode;
                flowPos.y += n2 * 0.4 * mode;
                flowPos.z += (n1 + n2) * 0.3 * mode;

                // æ‰‹éƒ¨å¸å¼•
                vec3 handPos3 = vec3(handPos.x, handPos.y, 0.0);
                vec3 toHand = handPos3 - flowPos;
                float dist = length(toHand);
                float attraction = 1.0 / (dist * dist + 0.05);
                attraction = min(attraction, 4.0);
                
                flowPos += toHand * attraction * 0.4 * mode;
                flowPos += (randoms - 0.5) * mode * 0.6; // éšæœºæ•£å¼€

                // æ··åˆ
                float mixFactor = smoothstep(0.0, 1.0, mode);
                vec3 finalPos = mix(targetPos, flowPos, mixFactor);

                // é¢œè‰²é‡‡æ ·
                vec4 texColor = texture2D(currentTex, uvRef);
                vColor = texColor.rgb ; // æ˜Ÿç©ºæ¨¡å¼ä¿æŒåŸè‰²

                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_PointSize = pointSize * (1.0 + mode * 0.5) * (10.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                if(length(coord) > 0.5) discard;
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        /**
         * 4. Three.js åˆå§‹åŒ–
         */
        function initThree() {
            // éšè—åŠ è½½å±‚
            loader.style.opacity = 0;
            setTimeout(() => loader.style.display = 'none', 500);
            statusText.innerHTML = "ç³»ç»Ÿå°±ç»ªï¼Œè¯·åœ¨æ‘„åƒå¤´å‰ä¸¾èµ·æ‰‹";

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç²’å­æ•°æ®
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const uvRefs = new Float32Array(CONFIG.particleCount * 2);
            const randoms = new Float32Array(CONFIG.particleCount * 3);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const u = (i % CONFIG.texSize) / CONFIG.texSize;
                const v = Math.floor(i / CONFIG.texSize) / CONFIG.texSize;
                
                uvRefs[i * 2] = u;
                uvRefs[i * 2 + 1] = 1.0 - v; // Flip Y

                randoms[i * 3] = Math.random();
                randoms[i * 3 + 1] = Math.random();
                randoms[i * 3 + 2] = Math.random();

                positions[i * 3] = 0; positions[i * 3 + 1] = 0; positions[i * 3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('uvRef', new THREE.BufferAttribute(uvRefs, 2));
            geometry.setAttribute('randoms', new THREE.BufferAttribute(randoms, 3));

            uniforms = {
                time: { value: 0 },
                mode: { value: 0 },
                handPos: { value: new THREE.Vector2(0, 0) },
                currentTex: { value: imageTextures[0] },
                pointSize: { value: CONFIG.pointSize * window.devicePixelRatio }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            window.addEventListener('resize', onWindowResize, false);
            
            animate();
            initMediaPipe();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.pointSize.value = CONFIG.pointSize * window.devicePixelRatio;
        }

        function animate() {
            requestAnimationFrame(animate);

            uniforms.time.value += 0.01;

            // æ¨¡å¼å¹³æ»‘è¿‡æ¸¡é€»è¾‘
            // æœ‰æ‰‹ä¸”å¼ å¼€ -> mode 1.0 (æ˜Ÿç³»)
            // æœ‰æ‰‹ä¸”æ¡æ‹³ -> mode 0.0 (è¿˜åŸ)
            // æ— æ‰‹ -> mode 0.0 (è¿˜åŸ)
            let targetMode = (STATE.isHandDetected && !STATE.isFist) ? 1.0 : 0.0;
            
            STATE.mode += (targetMode - STATE.mode) * 0.05;
            uniforms.mode.value = STATE.mode;

            // æ˜ å°„æ‰‹éƒ¨ä½ç½®
            const aspect = window.innerWidth / window.innerHeight;
            const viewHeight = 2.0 * Math.tan((camera.fov * Math.PI / 180) / 2) * camera.position.z;
            const viewWidth = viewHeight * aspect;

            uniforms.handPos.value.set(
                STATE.handPosition.x * (viewWidth / 2),
                STATE.handPosition.y * (viewHeight / 2)
            );

            // æ¡æ‹³åˆ‡æ¢è§¦å‘å™¨
            if (STATE.isHandDetected && STATE.isFist && !STATE.lastFistState) {
                triggerImageSwitch();
            }
            STATE.lastFistState = STATE.isFist;

            renderer.render(scene, camera);
        }

        function triggerImageSwitch() {
            let nextIndex = currentImageIndex;
            while (nextIndex === currentImageIndex) {
                nextIndex = Math.floor(Math.random() * imageTextures.length);
            }
            currentImageIndex = nextIndex;
            uniforms.currentTex.value = imageTextures[currentImageIndex];
            statusText.style.borderLeftColor = "#ff4d4d"; // çº¢è‰²æç¤ºæŠ“å–
            setTimeout(() => statusText.style.borderLeftColor = "#4db8ff", 300);
        }

        /**
         * 5. MediaPipe Hands Setup
         */
        function initMediaPipe() {
            const videoElement = document.getElementsByClassName('input_video')[0];
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraUtils.start().catch(err => {
                console.error("Camera Error:", err);
                statusText.innerHTML = "âš ï¸ æ— æ³•å¯åŠ¨æ‘„åƒå¤´! è¯·ç¡®ä¿ä½¿ç”¨ https æˆ– localhost";
                statusText.style.borderLeftColor = "red";
            });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // è®¡ç®—ä¸­å¿ƒ (Index 9 æ˜¯ä¸­æŒ‡æ ¹éƒ¨ï¼Œæ¯”è¾ƒç¨³å®š)
                // ä¹Ÿå¯ä»¥ç”¨å¹³å‡å€¼ï¼Œè¿™é‡Œç”¨ 9 å·ç‚¹ç®€åŒ–
                const p = landmarks[9]; 
                
                // åæ ‡è½¬æ¢: MediaPipe(0~1) -> WebGL(-1~1)
                // Xè½´ç¿»è½¬å› ä¸ºæ˜¯é•œåƒ
                STATE.handPosition.x = -(p.x - 0.5) * 2; 
                STATE.handPosition.y = -(p.y - 0.5) * 2;

                // æ¡æ‹³æ£€æµ‹
                STATE.isFist = isFistGesture(landmarks);
                
                if(STATE.isFist) {
                    statusText.innerHTML = "çŠ¶æ€: âœŠ <b>æ¡æ‹³</b> (æŠ“å–åˆ‡æ¢)";
                } else {
                    statusText.innerHTML = "çŠ¶æ€: ğŸ–ï¸ <b>å¼ å¼€</b> (å¼•åŠ›æµä½“)";
                }

            } else {
                STATE.isHandDetected = false;
                STATE.isFist = false;
                statusText.innerHTML = "æœªæ£€æµ‹åˆ°æ‰‹ (è¿˜åŸç”»ä½œ)";
            }
        }

        function isFistGesture(landmarks) {
            const wrist = landmarks[0];
            const fingerTips = [8, 12, 16, 20]; // é£ŸæŒ‡åˆ°å°æŒ‡å°–
            const fingerPips = [6, 10, 14, 18]; // è¿‘ç«¯å…³èŠ‚
            
            let foldedCount = 0;
            for (let i = 0; i < 4; i++) {
                const dTip = dist(landmarks[fingerTips[i]], wrist);
                const dPip = dist(landmarks[fingerPips[i]], wrist);
                if (dTip < dPip) foldedCount++;
            }
            return foldedCount >= 3; // ç¨å¾®å®½æ¾ä¸€ç‚¹ï¼Œ3æŒ‡å¼¯æ›²å³è§†ä¸ºæ¡æ‹³
        }

        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // å¯åŠ¨
        preloadImages();

    </script>
</body>
</html>
